# 仮想マシン仕様書

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [仮想マシン仕様書](#仮想マシン仕様書)
  - [処理系の概観](#処理系の概観)
    - [全体の処理フロー](#全体の処理フロー)
    - [フロントエンド](#フロントエンド)
    - [仮想マシンでの処理](#仮想マシンでの処理)
    - [フロントエンドと仮想マシンの協調](#フロントエンドと仮想マシンの協調)
  - [仮想マシンの設計](#仮想マシンの設計)
    - [クラス図](#クラス図)
    - [集合の定義](#集合の定義)
      - [外延表記](#外延表記)
      - [内包表記](#内包表記)
      - [集合算](#集合算)
  - [内包表記の基本](#内包表記の基本)
  - [複雑な条件，ドメイン集合の扱い](#複雑な条件ドメイン集合の扱い)
      - [等価演算子( = )](#等価演算子--)
      - [非等価演算子 ( != )](#非等価演算子---)
    - [より複雑な場合](#より複雑な場合)

<!-- /code_chunk_output -->

## 処理系の概観

### 全体の処理フロー

処理系は大きく分けて二つの部分から構成される．一つはフロントエンドであり，「P~Set言語」のプログラムを入力とし，S式のような構造体をテキストで出力する．もう一方はバックエンドであり，S式ライクの構造体を入力とし，実際に処理を行う．したがって，仮想マシンあるいはバックエンドが扱うのはLispのS式とほぼ同じフォーマットの構造体のみということになる．

<img src="./Flow_Overview.svg" />

### フロントエンド

フロントエンドはlexとyaccを用いた翻訳機のような役割を果たしている．フロントエンドに入力する言語は，今回我々が独自に開発した集合を扱うためのプログラミング言語である．この言語に関する詳細な仕様は「言語仕様書.pdf」で取り扱っているため，そちらを参照していただきたい．

### 仮想マシンでの処理

仮想マシンの仕事は，前述の通り，S式を受け取って集合演算処理を行うことである．この言語において，主な仕事は二つある．一つは集合の定義で，もう一つは質問（あるいは証明）である．下の図は仮想マシンの内部の大まかなデータフローを表している．フロントエンドから送られてきたS式の文字列を受け取ると，S式の構文解析が行われ，Javaの構造体として扱うことができるようになる．この構造体はいわゆる二進木の形式をしている．プログラムの評価は，この二進木をトップレベルから順に辿ることで行われる．

<img src="./VirtualMachineFlow.svg">

例えば，トップレベルの二進木で，car部のトークンが「ASSERT」と一致すれば，cdr部に格納されている部分木は集合定義式であることが確定する．したがって，以降の処理を集合定義処理に委譲する．あるいは，car部のトークンが「PROVE」と一致した場合は，cdr部の評価を質問処理に委譲するいといった動作をする．

集合定義の処理では，トップレベルのシンボルテーブルに新しく集合が定義される．また，質問処理では，トップレベルのシンボルテーブルを適宜参照しながら質問に答えるといった処理を行う．

### フロントエンドと仮想マシンの協調

仮想マシンとフロントエンドのバイナリは別々のプロセスとして動作している．したがって，この二つのプロセスがどうのようにして協調動作を実現しているかを述べておかなければならない．


↓↓フロントエンドと仮想マシンの協調方式を変える可能性がある↓↓
~~結論から述べると，仮想マシンとフロントエンドは標準入出力をパイプで接続することで通信を行なっている．仮想マシンは起動すると同時に，フロントエンドを子プロセスとして起動する．このままでは子プロセスで入出力が発生しないため適切にストリームを繋ぐ必要がある．~~


## 仮想マシンの設計

### クラス図

以下に示すものが仮想マシンのクラス図である．エントリポイントはMainクラスである．このクラスで標準入力の読み取り，パーサや評価器の起動などを行なっている．また，グローバル空間のシンボルテーブルもここで作成される．

<img src="./class_diagram_of_virtual_machine.svg" />

注意すべきは，Expression（式）というクラスが2ヶ所に現れているという点である．MathExpressionとSetExpressionが存在するが，これらは互いに無関係である．MathExpressionは算術にまつわる式を表現するオブジェクトであり，SetExpressionは集合演算にまつわるオブジェクトである．算術演算では被演算子はPValue（値）であるのに対し，SetExpressionでの被演算子はPSet（集合）である．

### 集合の定義

集合の定義には，外延表記，内包表記，集合演算の三つの定義方法がある．フロントエンドに，次のような文を入力することで，集合定義に関するS式が得られる．

```
A_set := <集合の定義>.
```

上のプログラムは以下のようなS式に変換される．重要な点は，S式のトップレベルにおけるcar部が`ASSERT`となっていること．そして，2番目の要素が`(UPPER_ID A_set)`である．続く3番目の要素は具体的な集合の内容を示すものとなる．この節では先に述べた三つの集合定義方法について，その内容を詳細に述べていく．

```
(ASSERT (UPPER_ID A_set)
    (...
        ...
        ))
```

#### 外延表記

集合の外延表記による定義は例えば以下のようなプログラムによって行える．外延表記では，`{}`の中に集合の要素としたい値を単に並べれば良い．

```
A_set := {1, 2, 3, 4, 5}.
```

このプログラムはフロントエンドの翻訳機によって，次のようなS式に変換される．リストの3番目の要素において，そのcar部が`EXTENSION`となっている点に注目していただきたい．これが外延表記であることのキーワードである．この場合，`cdr`部には集合の要素のリストが格納されているものとみなされる．実際に`SETELEMENTS`というのが集合の要素を連ねたものとなる．

処理系は外延表記で定義された値から新たな集合を作成すると同時に，`UPPER_ID`のところで定義された集合名とともにシンボルテーブルに登録する．すでに登録されていた場合は上書きとなる．この登録によって，以降，この名前を用いて集合を参照することが可能となる．

```
(ASSERT (UPPER_ID A_set) 
    (EXTENSION 
        (SETELEMENTS 
            (SETELEMENT (INTEGER 1)) 
            (SETELEMENT (INTEGER 2)) 
            (SETELEMENT (INTEGER 3)) 
            (SETELEMENT (INTEGER 4)) 
            (SETELEMENT (INTEGER 5)))))
```

#### 内包表記

この処理系において一番厄介であるのが内包表記による集合定義である．

#### 集合算


## 内包表記の基本

ここで，Nは外延表記で定義される集合である．対してAは内包表記で定義される集合である．内包表記に馴染みのある人ならだいたい意味は通じるだろう．ここで，`;`はORを意味する．`,`はANDを意味する．`~`は∈と同じ意味である．また，集合に属する元を変数で宣言するが，`|x|`のように２本の縦棒で囲むようにする．

```
N := {1, 2, 3, 4, 5}.
A := {|x| (x = 5*y ; x = 6*y), y~N}.
```

このプログラムは以下のようなS式ライクの表現に変換される．VMはこれを受け取り処理をする．（実際はもう少し複雑）

```
(ASSERT
  (UPPER_ID N)
  (EXTENSION (1 2 3 4 5)))
(ASSERT
  (UPPER_ID A)
  (INTENSION
    (LOWER_ID x)
    (AND
      (OR (= x (* 5 y)) (= x (* 6 y)))
      (IN y N))))
```

---

## 複雑な条件，ドメイン集合の扱い

以下のような集合定義を処理する方法について述べる．以下の文では，集合`A`の元は変数`x`のうち，条件を満たすもの，と定義している．
```
A := {|x| x = 3 *y, x = 2*y, y~N}.

(ASSERT (UPPER_ID A) 
    (INTENSION 
        (SETELEMENT (LOWER_ID x)) 
        (AND 
            (AND 
                (= (LOWER_ID x) 
                    (* (INTEGER 3) (LOWER_ID y))) 
                (= (LOWER_ID x) 
                    (* (INTEGER 2) (LOWER_ID y)))) 
            (~ 
                (SETELEMENT (LOWER_ID y)) 
                (EXPRESSION (UPPER_ID N))))))
```

注目すべき点は，変数`x`に関する条件が２つあることだ．このような場合はまず，変数の付け替えを行う必要がある．つまり以下のような２つの条件に置き換えられる．

```
x1 = 3*y
x2 = 2*y
```

次に，`y~N`という部分に注目する．これは変数`y`は`N`の元であるという意味だが，集合を生成する際には`for-each`のような働きをする．より具体的に，ある条件式と，帰属関係式（`y~N`の形をした式）からなるAND条件(以下のS式)があるとする．

```
(AND
  (...条件...)
  (~
    (SETELEMENT (LOWER_ID y)
    (EXPRESSION (UPPER_ID N)))))
```

まず，条件の展開が行われる．変数`y`が属する集合`N`が，たとえば`{1, 2, 3, 4}`のような集合だったとしよう．すると，展開して得られる条件式は以下のようになる．ここでは変数`y`を受け取って評価する条件を`P(y)`としている．

```
// 展開前
A := {|x| x = P(y), y~N}.

// 展開後
A := {|x| (x = P(1); x = P(2); x = P(3); x = P(4))}
```

**ANDやORを含む条件式の展開**

```
 // 展開前
A := {|x| x = 2*y, x = 3*y, y~N}.

// 変数名の付け替え
A := {|x| x = 2*y1, x = 3*y2, y1~N, y2~N}.

// 展開
A := {|x| x = 2*y1, x = 3*y2, y1~N, y2~N}.
```

条件の展開により，要素変数以外の変数が消去できた場合，評価が行われる．評価によって集合の要素になるかどうかが確定する．評価の方法は条件演算子の種類によって変わる．

#### 等価演算子( = )

右辺もしくは左辺の一方が要素変数（`x`のような）である場合に評価が成功する．要素の値は要素変数とは反対の辺の値となる．

```
// 良い例
x = 2 --> PInteger(2)
3 = x --> PInteger(3)

// ダメな例
x + 1 = 3 --> null
x = x  --> null
```

#### 非等価演算子 ( != )

### より複雑な場合

次はもっと複雑な場合である．以下は条件が２つで，変数も２つある場合だ．

```
A := {|x| x = 2*y+3*z, x = 3*y+4*z, y~N, z~N}.

(ASSERT (UPPER_ID A) 
    (INTENSION 
        (SETELEMENT (LOWER_ID x)) 
        (AND 
            (AND 
                (AND 
                    (= (LOWER_ID x) 
                        (+ 
                            (* (INTEGER 2) (LOWER_ID y)) 
                            (* (INTEGER 3) (LOWER_ID z)))) 
                    (= (LOWER_ID x) 
                        (+ 
                            (* (INTEGER 3) (LOWER_ID y)) 
                            (* (INTEGER 4) (LOWER_ID z))))) 
                (~ 
                    (SETELEMENT (LOWER_ID y)) 
                    (EXPRESSION (UPPER_ID N)))) 
            (~ 
                (SETELEMENT (LOWER_ID z)) 
                (EXPRESSION (UPPER_ID N))))))
```

```py
for z in N:
  for y in N:
    value = cond(elementName, y, z)
    if value is not None:
      set.add(value)
```

---

要素が順序対（タプル）の集合

```
A(N) := {|(x, y)| x=2*y, y~N}.
```

```lisp
(ASSERT
  (A, N)
  (x y)
  (AND
    (= x (* 2 y))
    (IN y N)))
```
