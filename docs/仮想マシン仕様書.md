# 仮想マシン仕様書


## 内包表記の基本

ここで，Nは外延表記で定義される集合である．対してAは内包表記で定義される集合である．内包表記に馴染みのある人ならだいたい意味は通じるだろう．ここで，`;`はORを意味する．`,`はANDを意味する．`~`は∈と同じ意味である．また，集合に属する元を変数で宣言するが，`|x|`のように２本の縦棒で囲むようにする．

```
N := {1, 2, 3, 4, 5}.
A := {|x| (x = 5*y ; x = 6*y), y~N}.
```

このプログラムは以下のようなS式ライクの表現に変換される．VMはこれを受け取り処理をする．（実際はもう少し複雑）

```
(ASSERT
  (UPPER_ID N)
  (EXTENSION (1 2 3 4 5)))
(ASSERT
  (UPPER_ID A)
  (INTENSION
    (LOWER_ID x)
    (AND
      (OR (= x (* 5 y)) (= x (* 6 y)))
      (IN y N))))
```

---

## 複雑な条件，ドメイン集合の扱い

以下のような集合定義を処理する方法について述べる．以下の文では，集合`A`の元は変数`x`のうち，条件を満たすもの，と定義している．
```
A := {|x| x = 3 *y, x = 2*y, y~N}.

(ASSERT (UPPER_ID A) 
    (INTENSION 
        (SETELEMENT (LOWER_ID x)) 
        (AND 
            (AND 
                (= (LOWER_ID x) 
                    (* (INTEGER 3) (LOWER_ID y))) 
                (= (LOWER_ID x) 
                    (* (INTEGER 2) (LOWER_ID y)))) 
            (~ 
                (SETELEMENT (LOWER_ID y)) 
                (EXPRESSION (UPPER_ID N))))))
```

注目すべき点は，変数`x`に関する条件が２つあることだ．このような場合はまず，変数の付け替えを行う必要がある．つまり以下のような２つの条件に置き換えられる．

```
x1 = 3*y
x2 = 2*y
```

次に，`y~N`という部分に注目する．これは変数`y`は`N`の元であるという意味だが，集合を生成する際には`for-each`のような働きをする．より具体的に，ある条件式と，帰属関係式（`y~N`の形をした式）からなるAND条件(以下のS式)があるとする．

```
(AND
  (...条件...)
  (~
    (SETELEMENT (LOWER_ID y)
    (EXPRESSION (UPPER_ID N)))))
```

まず，条件の展開が行われる．変数`y`が属する集合`N`が，たとえば`{1, 2, 3, 4}`のような集合だったとしよう．すると，展開して得られる条件式は以下のようになる．ここでは変数`y`を受け取って評価する条件を`P(y)`としている．

```
// 展開前
A := {|x| x = P(y), y~N}.

// 展開後
A := {|x| (x = P(1); x = P(2); x = P(3); x = P(4))}
```

**ANDやORを含む条件式の展開**

```
 // 展開前
A := {|x| x = 2*y, x = 3*y, y~N}.

// 変数名の付け替え
A := {|x| x = 2*y1, x = 3*y2, y1~N, y2~N}.

// 展開
A := {|x| x = 2*y1, x = 3*y2, y1~N, y2~N}.
```

条件の展開により，要素変数以外の変数が消去できた場合，評価が行われる．評価によって集合の要素になるかどうかが確定する．評価の方法は条件演算子の種類によって変わる．

#### 等価演算子( = )

右辺もしくは左辺の一方が要素変数（`x`のような）である場合に評価が成功する．要素の値は要素変数とは反対の辺の値となる．

```
// 良い例
x = 2 --> PInteger(2)
3 = x --> PInteger(3)

// ダメな例
x + 1 = 3 --> null
x = x  --> null
```

#### 非等価演算子 ( != )

### より複雑な場合

次はもっと複雑な場合である．以下は条件が２つで，変数も２つある場合だ．

```
A := {|x| x = 2*y+3*z, x = 3*y+4*z, y~N, z~N}.

(ASSERT (UPPER_ID A) 
    (INTENSION 
        (SETELEMENT (LOWER_ID x)) 
        (AND 
            (AND 
                (AND 
                    (= (LOWER_ID x) 
                        (+ 
                            (* (INTEGER 2) (LOWER_ID y)) 
                            (* (INTEGER 3) (LOWER_ID z)))) 
                    (= (LOWER_ID x) 
                        (+ 
                            (* (INTEGER 3) (LOWER_ID y)) 
                            (* (INTEGER 4) (LOWER_ID z))))) 
                (~ 
                    (SETELEMENT (LOWER_ID y)) 
                    (EXPRESSION (UPPER_ID N)))) 
            (~ 
                (SETELEMENT (LOWER_ID z)) 
                (EXPRESSION (UPPER_ID N))))))
```

```py
for z in N:
  for y in N:
    value = cond(elementName, y, z)
    if value is not None:
      set.add(value)
```

---

要素が順序対（タプル）の集合

```
A(N) := {|(x, y)| x=2*y, y~N}.
```

```lisp
(ASSERT
  (A, N)
  (x y)
  (AND
    (= x (* 2 y))
    (IN y N)))
```
